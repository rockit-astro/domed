#!/usr/bin/env python3
#
# This file is part of domed.
#
# domed is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# domed is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with domed.  If not, see <http://www.gnu.org/licenses/>.

"""Commandline client for controlling domed"""

import datetime
import glob
import os
import sys
import Pyro4
from warwick.observatory.dome import (
    Config,
    CommandStatus,
    DomeShutterStatus,
    DomeHeartbeatStatus)
from warwick.observatory.common import TFmt

SCRIPT_NAME = os.path.basename(sys.argv[0])
sys.excepthook = Pyro4.util.excepthook


def run_command(command, args):
    """Runs a daemon command, handling error messages"""
    if 'DOMED_CONFIG_PATH' in os.environ:
        config = Config(os.environ['DOMED_CONFIG_PATH'])
    else:
        # Load the config file defined in the DOMED_CONFIG_PATH environment variable or from the
        # default system location (/etc/domed/). Exit with an error if zero or multiple are found.
        files = glob.glob("/etc/domed/*.json")
        if len(files) != 1:
            print('error: failed to guess the default config file. ' +
                  'Run as DOMED_CONFIG_PATH=/path/to/config.json dome <command>')
            return 1

        config = Config(files[0])

    try:
        ret = command(config, args)
    except KeyboardInterrupt:
        # ctrl-c terminates the running command
        ret = stop(config, args)

        # Report successful stop
        if ret == 0:
            ret = -100
    except Pyro4.errors.CommunicationError:
        ret = -101

    # Print message associated with error codes, except for -1 (error handled locally)
    if ret not in [-1, 0]:
        print(CommandStatus.message(ret))
    sys.exit(ret)


def print_status(config, _):
    """Prints the dome status in human-readable form"""
    with config.daemon.connect() as dome:
        status = dome.status()

    date = datetime.datetime.strptime(status['date'], '%Y-%m-%dT%H:%M:%SZ')
    heartbeat_date = datetime.datetime.strptime(status['heartbeat_date'], '%Y-%m-%dT%H:%M:%SZ')
    eng_mode = TFmt.Red + 'ENABLED' if status['engineering_mode'] else TFmt.Green + 'DISABLED'
    siren_mode = TFmt.Green + 'ENABLED' if status['heartbeat_siren'] else TFmt.Red + 'DISABLED'

    print('Dome status at: {0}'.format(TFmt.Bold + str(date) + TFmt.Clear))
    for side in ['a', 'b']:
        side_label = f' {config.side_labels[side]} shutter: ' + \
                DomeShutterStatus.label(status[f'shutter_{side}'], formatting=True)
        if f'belt_{side}_tensioned' in status:
            belt_label = TFmt.Green + 'TENSIONED' if status[f'belt_{side}_tensioned'] else TFmt.Red + 'SLACK'
            side_label += f' (belt {TFmt.Bold}{belt_label}{TFmt.Clear})'

        print(side_label)

    print('     Eng. mode: {}'.format(TFmt.Bold + eng_mode + TFmt.Clear))
    print('Heartbeat status at: {0}'.format(TFmt.Bold + str(heartbeat_date) + TFmt.Clear))
    print('       Monitor: ' + DomeHeartbeatStatus.label(status['heartbeat_status'], formatting=True))
    print('         Siren: ' + TFmt.Bold + siren_mode + TFmt.Clear)

    if status['heartbeat_status'] == 1:
        print('Time remaining: {}'.format(TFmt.Bold + str(status['heartbeat_remaining']) + TFmt.Clear))

    return 0


def stop(config, _):
    """Stops any active dome movement"""
    with config.daemon.connect() as dome:
        return dome.stop()


def open_dome(config, args):
    """Opens the dome shutters"""
    if args:
        steps = int(args[1]) if len(args) > 1 else 0
        with config.daemon.connect(timeout=0) as dome:
            if args[0] in config.sides:
                return dome.open_shutters(config.sides[args[0]], steps=steps)

    print('usage: {} open ({}) [<steps>]'.format(SCRIPT_NAME, '|'.join(config.sides.keys())))
    return -1


def close_dome(config, args):
    """Closes the dome shutters"""
    if args:
        steps = int(args[1]) if len(args) > 1 else 0
        with config.daemon.connect(timeout=0) as dome:
            if args[0] in config.sides:
                sides = config.sides[args[0]]

                # Reverse the shutter order when closing
                if config.invert_on_close:
                    sides = sides[::-1]

                return dome.close_shutters(sides, steps=steps)

    print('usage: {} close ({}) [<steps>]'.format(SCRIPT_NAME, '|'.join(config.sides.keys())))
    return -1


def heartbeat(config, args):
    """Configure the dome close heartbeat"""
    if args:
        with config.daemon.connect() as dome:
            if args[0] == 'disable':
                return dome.set_heartbeat_timer(0)

            if args[0] == 'enable':
                if len(args) > 1:
                    timeout = int(args[1])
                    if timeout > 0:
                        return dome.set_heartbeat_timer(timeout)
            print('usage: {} heartbeat enable <timeout in seconds>'.format(SCRIPT_NAME))
            return -1
    print('usage: {} heartbeat (disable|enable)'.format(SCRIPT_NAME))
    return -1


def engineering_mode(config, args):
    """Enable or disable engineering mode to disable dome movement"""
    if args:
        with config.daemon.connect() as dome:
            if args[0] == 'disable':
                return dome.set_engineering_mode(False)

            if args[0] == 'enable':
                return dome.set_engineering_mode(True)

    print('usage: {} engineering (disable|enable)'.format(SCRIPT_NAME))
    return -1


def siren(config, args):
    """Enable or disable heartbeat siren"""
    if args:
        with config.daemon.connect() as dome:
            if args[0] == 'disable':
                return dome.set_heartbeat_siren(False)

            if args[0] == 'enable':
                return dome.set_heartbeat_siren(True)

    print('usage: {} siren (disable|enable)'.format(SCRIPT_NAME))
    return -1


def print_usage():
    """Prints the utility help"""
    print('Usage: {} <command>'.format(SCRIPT_NAME))
    print()
    print('   status        print a human-readable summary of the dome status')
    print('   open          open one or both shutters')
    print('   close         close one or both shutters')
    print('   stop          stop manual open/close command (excludes heartbeat)')
    print('   heartbeat     configure the dome auto-close timeout')
    print('   siren         configure the dome siren')
    print('   engineering   enable or disable engineering mode')
    print()

    return 1


def list_sides(config, _):
    """Prints a list of the switchable parameters"""
    print(' '.join(config.sides.keys()))
    return 0


if __name__ == '__main__':
    commands = {
        'status': print_status,
        'open': open_dome,
        'close': close_dome,
        'stop': stop,
        'heartbeat': heartbeat,
        'siren': siren,
        'engineering': engineering_mode,
        'list-sides': list_sides
    }

    if len(sys.argv) >= 2 and sys.argv[1] in commands:
        sys.exit(run_command(commands[sys.argv[1]], sys.argv[2:]))

    sys.exit(print_usage())

#!/usr/bin/env python3
#
# This file is part of domed.
#
# domed is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# domed is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with domed.  If not, see <http://www.gnu.org/licenses/>.

"""Dome daemon for the Warwick one-metre telescope"""

# pylint: disable=too-few-public-methods
# pylint: disable=too-many-instance-attributes
# pylint: disable=broad-except
# pylint: disable=invalid-name

import argparse
import datetime
import threading
import time
import Pyro4
import serial
import warwick.observatory as observatory
from warwick.observatory import TryLock

class DomeConfig:
    """Helper class containing dome configuration values"""
    def __init__(self, log_name, daemon, serial_port, serial_baud=9600, serial_timeout_seconds=3,
                 shutter_timeout_seconds=60,
                 command_delay_seconds=0.5, legacy_controller=False,
                 heartbeat_port=None, heartbeat_baud=9600, heartbeat_timeout_seconds=3):
        self.log_name = log_name
        self.daemon = daemon
        self.serial_port = serial_port
        self.serial_baud = serial_baud
        self.serial_timeout_seconds = serial_timeout_seconds
        self.command_delay_seconds = command_delay_seconds
        self.shutter_timeout_seconds = shutter_timeout_seconds
        self.legacy_controller = legacy_controller
        self.heartbeat_port = heartbeat_port
        self.heartbeat_baud = heartbeat_baud
        self.heartbeat_timeout_seconds = heartbeat_timeout_seconds

DOME_CONFIG = {
    'onemetre': DomeConfig('onemetre_dome',
                           observatory.daemons.onemetre_dome,
                           serial_port='/dev/ttyS0'),
    'nites': DomeConfig('nites_dome',
                        observatory.daemons.nites_dome,
                        serial_port='COM8',
                        serial_timeout_seconds=0.5,
                        shutter_timeout_seconds=8.5,
                        legacy_controller=True,
                        heartbeat_port='COM9')
}

# This should be kept in sync with the dictionary in dome
class CommandStatus:
    """Numeric return codes"""
    # General error codes
    Succeeded = 0
    Failed = 1
    Blocked = 2
    HeartbeatTimedOut = 3
    HeartbeatCloseInProgress = 4
    HeartbeatUnavailable = 5
    HeartbeatInvalidTimeout = 6

class DomeShutterStatus:
    """Status of the dome shutters"""
    Closed, Open, PartiallyOpen, Opening, Closing, HeartbeatMonitorForceClosing = range(6)

class DomeHeartbeatStatus:
    """Status of the dome heartbeat monitoring"""
    Disabled, Active, TrippedClosing, TrippedIdle, Unavailable = range(5)

class DomeDaemon:
    """Daemon class that wraps the RS232 interface"""
    def __init__(self, config):
        self._config = config
        self._port = None

        self._status_lock = threading.Lock()
        self._status_time = None
        self._east_shutter = DomeShutterStatus.Closed
        self._west_shutter = DomeShutterStatus.Closed

        self._command_lock = threading.Lock()
        self._force_stopped = False

        runloop = threading.Thread(target=self.__monitor_dome_status)
        runloop.daemon = True
        runloop.start()

        self._heartbeat_port = None
        self._heartbeat_status = DomeHeartbeatStatus.Unavailable
        self._heartbeat_time_remaining = 0
        self._heartbeat_date = datetime.datetime.utcnow()

        if self._config.heartbeat_port:
            heartbeat = threading.Thread(target=self.__monitor_heartbeat)
            heartbeat.daemon = True
            heartbeat.start()

    def __monitor_dome_status(self):
        """Monitors the status of the dome by reading serial port"""
        while True:
            # Initial setup
            try:
                self._port = serial.Serial(self._config.serial_port,
                                           self._config.serial_baud,
                                           timeout=self._config.serial_timeout_seconds)
            except Exception as exception:
                print(exception)
                print('Will retry in 5 seconds...')
                observatory.log.error(self._config.log_name,
                                      'Failed to connect to serial port (' + str(exception) + ')')
                time.sleep(5.)
                continue

            try:
                print('Connected to dome on', self._config.serial_port)
                observatory.log.info(self._config.log_name,
                                     'Connected to dome on ' + self._config.serial_port)

                # Flush any stale state
                self._port.flushInput()
                self._port.flushOutput()

                if self._config.legacy_controller:
                    # The older non-PLC controllers will only return A/B/X/Y status bytes in
                    # response to an issued move command. We therefore need to try closing a
                    # step to find out where the shutters are now
                    self.__move_shutter('A', lambda runtime: True)
                    self.__move_shutter('B', lambda runtime: True)

                # Main run loop
                while True:
                    data = self._port.read(1)

                    if len(data) == 0:
                        if self._config.legacy_controller:
                            # Legacy controllers only send data in response to a move command
                            continue
                        else:
                            raise serial.SerialTimeoutException('Read timeout')

                    with self._status_lock:
                        self.__parse_status(data[0])
                        self._status_time = datetime.datetime.utcnow()

            except Exception as exception:
                self._port.close()
                print(exception)
                print('Will retry in 5 seconds...')
                observatory.log.error(self._config.log_name, 'Failed to read serial port (' \
                                      + str(exception) + ')')
                time.sleep(5.)

    def __parse_status(self, status):
    # pylint: disable=too-many-branches
        if status == ord('0'):
            self._east_shutter = DomeShutterStatus.Closed
            self._west_shutter = DomeShutterStatus.Closed
        elif status == ord('1'):
            self._east_shutter = DomeShutterStatus.Closed
            if self._west_shutter != DomeShutterStatus.Open:
                self._west_shutter = DomeShutterStatus.PartiallyOpen
        elif status == ord('2'):
            if self._east_shutter != DomeShutterStatus.Open:
                self._east_shutter = DomeShutterStatus.PartiallyOpen
            self._west_shutter = DomeShutterStatus.Closed
        elif status == ord('3'):
            if self._east_shutter != DomeShutterStatus.Open:
                self._east_shutter = DomeShutterStatus.PartiallyOpen
            if self._west_shutter != DomeShutterStatus.Open:
                self._west_shutter = DomeShutterStatus.PartiallyOpen
        elif status == ord('A'):
            if self._config.legacy_controller:
                self._east_shutter = DomeShutterStatus.PartiallyOpen
            else:
                self._east_shutter = DomeShutterStatus.Closing
        elif status == ord('a'):
            if self._config.legacy_controller:
                self._east_shutter = DomeShutterStatus.PartiallyOpen
            else:
                self._east_shutter = DomeShutterStatus.Opening
        elif status == ord('X'):
            self._east_shutter = DomeShutterStatus.Closed
        elif status == ord('x'):
            self._east_shutter = DomeShutterStatus.Open
        elif status == ord('B'):
            if self._config.legacy_controller:
                self._west_shutter = DomeShutterStatus.PartiallyOpen
            else:
                self._west_shutter = DomeShutterStatus.Closing
        elif status == ord('b'):
            if self._config.legacy_controller:
                self._west_shutter = DomeShutterStatus.PartiallyOpen
            else:
                self._west_shutter = DomeShutterStatus.Opening
        elif status == ord('Y'):
            self._west_shutter = DomeShutterStatus.Closed
        elif status == ord('y'):
            self._west_shutter = DomeShutterStatus.Open
        else:
            print('Unknown status code: {0}'.format(status))
            observatory.log.error(self._config.log_name, 'Unknown dome status code ' \
                                                         + str(status))
    # pylint: enable=too-many-branches

    def __monitor_heartbeat(self):
        """Monitors the heartbeat timer and close the dome if it expires"""
        while True:
            # Initial setup
            try:
                self._heartbeat_port = serial.Serial(self._config.heartbeat_port,
                                                     self._config.heartbeat_baud,
                                                     timeout=self._config.heartbeat_timeout_seconds)
            except Exception as exception:
                print('Failed to open heartbeat monitor connection with error:')
                print(exception)
                print('Will retry in 5 seconds...')
                if self._heartbeat_status != DomeHeartbeatStatus.Unavailable:
                    observatory.log.error(self._config.log_name,
                                          'Failed to connect to heartbeat monitor (' \
                                          + str(exception) + ')')
                time.sleep(5.)

                self._heartbeat_status = DomeHeartbeatStatus.Unavailable
                continue

            try:
                print('Connected to heartbeat monitor on', self._config.heartbeat_port)
                observatory.log.info(self._config.log_name,
                                     'Connected to heartbeat monitor on ' \
                                     + self._config.heartbeat_port)

                # Flush any stale state
                self._heartbeat_port.flushInput()
                self._heartbeat_port.flushOutput()
                self._heartbeat_status = DomeHeartbeatStatus.Disabled

                # Main run loop
                while True:
                    data = self._heartbeat_port.read(1)
                    if len(data) == 0:
                        raise serial.SerialTimeoutException('Read timeout')

                    status = data[-1]
                    with self._status_lock:
                        self._heartbeat_time_remaining = 0
                        if status == 254:
                            if self._heartbeat_status != DomeHeartbeatStatus.TrippedClosing:
                                observatory.log.error(self._config.log_name,
                                                      'Heartbeat monitor is closing dome')
                            self._heartbeat_status = DomeHeartbeatStatus.TrippedClosing
                            self._east_shutter = DomeShutterStatus.HeartbeatMonitorForceClosing
                            self._west_shutter = DomeShutterStatus.HeartbeatMonitorForceClosing
                            self._status_time = datetime.datetime.utcnow()
                        elif status == 255:
                            if self._heartbeat_status != DomeHeartbeatStatus.TrippedIdle:
                                observatory.log.error(self._config.log_name,
                                                      'Heartbeat monitor has finished closing dome')
                            if self._heartbeat_status != DomeHeartbeatStatus.TrippedIdle \
                                    and self._config.legacy_controller:
                                # The heartbeat monitor disconnects the dome serial connection when
                                # it is closing the dome, so we don't know for sure what the current
                                # status of the dome is now. Issue another close step so that we can
                                # receive a new status update
                                self.__move_shutter('A', lambda runtime: True)
                                self.__move_shutter('B', lambda runtime: True)
                            self._heartbeat_status = DomeHeartbeatStatus.TrippedIdle
                        elif status == 0:
                            if self._heartbeat_status != DomeHeartbeatStatus.Disabled:
                                observatory.log.info(self._config.log_name, 'Heartbeat disabled')
                            self._heartbeat_status = DomeHeartbeatStatus.Disabled
                        else:
                            if self._heartbeat_status != DomeHeartbeatStatus.Active:
                                observatory.log.info(self._config.log_name, 'Heartbeat enabled')
                            self._heartbeat_status = DomeHeartbeatStatus.Active

                            # Heartbeat monitor represents time using half-second ticks
                            self._heartbeat_time_remaining = status / 2.

                        self._heartbeat_date = datetime.datetime.utcnow()

            except Exception as exception:
                self._heartbeat_port.close()
                self._heartbeat_status = DomeHeartbeatStatus.Unavailable
                print(exception)
                print('Will retry in 5 seconds...')
                observatory.log.error(self._config.log_name, 'Failed to read heartbeat monitor (' \
                                      + str(exception) + ')')
                time.sleep(5.)

    def __move_shutter(self, command, at_requested_limit):
        """Issues a dome command and blocks until the final state is reached (or timeout)"""
        starttime = datetime.datetime.utcnow()
        while True:
            try:
                length = self._port.write(command.encode('ascii'))
                if length != 1:
                    raise serial.SerialException('Failed to send command ' + command)
            except Exception as exception:
                observatory.log.error(self._config.log_name, 'Failed to send serial command (' \
                                      + str(exception) + ')')
            time.sleep(self._config.command_delay_seconds)
            runtime = (datetime.datetime.utcnow() - starttime).total_seconds()
            heartbeat_tripped = self._heartbeat_status == DomeHeartbeatStatus.TrippedClosing or \
                self._heartbeat_status == DomeHeartbeatStatus.TrippedIdle
            at_limit = at_requested_limit(runtime)
            if self._force_stopped or heartbeat_tripped or at_limit \
                    or runtime > self._config.shutter_timeout_seconds:
                break

        return not self._force_stopped and not heartbeat_tripped and at_limit

    def __open_shutters(self, east, west):
        """Open the requested shutters"""
        success = True

        # TODO: Check the wind direction and open the downwind shutter first
        if east:
            at_requested_limit = lambda runtime: self._east_shutter == DomeShutterStatus.Open
            success = success and self.__move_shutter('a', at_requested_limit)

        if west:
            at_requested_limit = lambda runtime: self._west_shutter == DomeShutterStatus.Open
            success = success and self.__move_shutter('b', at_requested_limit)
        return success

    def __close_shutters(self, east, west):
        """Close the requested shutters"""
        success = True

        # TODO: Check the wind direction and close the upwind shutter first
        if east:
            at_requested_limit = lambda runtime: self._east_shutter == DomeShutterStatus.Closed
            success = success and self.__move_shutter('A', at_requested_limit)

        if west:
            at_requested_limit = lambda runtime: self._west_shutter == DomeShutterStatus.Closed
            success = success and self.__move_shutter('B', at_requested_limit)
        return success

    @Pyro4.expose
    def open_shutters(self, east=False, west=False):
        """Opens the requested shutter.
           Returns once the requested shutters reach their limits or the command times out."""
        if self._heartbeat_status == DomeHeartbeatStatus.TrippedClosing:
            return CommandStatus.HeartbeatCloseInProgress

        if self._heartbeat_status == DomeHeartbeatStatus.TrippedIdle:
            return CommandStatus.HeartbeatTimedOut

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if east and west:
                observatory.log.info(self._config.log_name, 'Opening both shutters')
            else:
                shutter = 'east' if east else 'west'
                observatory.log.info(self._config.log_name, 'Opening ' + shutter + ' shutter')

            if not self.__open_shutters(east, west):
                observatory.log.error(self._config.log_name, 'Failed to open dome')
                return CommandStatus.Failed

            observatory.log.info(self._config.log_name, 'Open complete')
            return CommandStatus.Succeeded

    @Pyro4.expose
    def close_shutters(self, east=False, west=False):
        """Closes the requested shutter.
           Returns once the requested shutters reach their limits or the command times out."""
        if self._heartbeat_status == DomeHeartbeatStatus.TrippedClosing:
            return CommandStatus.HeartbeatCloseInProgress

        if self._heartbeat_status == DomeHeartbeatStatus.TrippedIdle:
            return CommandStatus.HeartbeatTimedOut

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if east and west:
                observatory.log.info(self._config.log_name, 'Closing both shutters')
            else:
                shutter = 'east' if east else 'west'
                observatory.log.info(self._config.log_name, 'Closing ' + shutter + ' shutter')

            if not self.__close_shutters(east, west):
                observatory.log.error(self._config.log_name, 'Failed to close dome')
                return CommandStatus.Failed

            observatory.log.info(self._config.log_name, 'Close complete')
            return CommandStatus.Succeeded

    @Pyro4.expose
    def stop(self):
        """Stops any active shutter movement"""
        if self._heartbeat_status == DomeHeartbeatStatus.TrippedClosing:
            return CommandStatus.HeartbeatCloseInProgress

        observatory.log.warning(self._config.log_name, 'Received stop command')

        # The stop command overrides all other commands
        self._force_stopped = True
        with self._command_lock:
            self._force_stopped = False

        return CommandStatus.Succeeded

    @Pyro4.expose
    def set_heartbeat_timer(self, timeout):
        """Enable or disable the auto-close countdown"""
        if self._heartbeat_status == DomeHeartbeatStatus.Unavailable:
            return CommandStatus.HeartbeatUnavailable

        if self._heartbeat_status == DomeHeartbeatStatus.TrippedClosing:
            return CommandStatus.HeartbeatCloseInProgress

        if timeout != 0 and self._heartbeat_status == DomeHeartbeatStatus.TrippedIdle:
            return CommandStatus.HeartbeatTimedOut

        if timeout < 0 or timeout >= 120:
            return CommandStatus.HeartbeatInvalidTimeout

        # Heartbeat monitor represents time using half-second ticks
        length = self._heartbeat_port.write(chr(2 * timeout).encode('ascii'))
        return CommandStatus.Succeeded if length == 1 else CommandStatus.Failed

    @Pyro4.expose
    def status(self):
        """Query the latest status."""
        with self._status_lock:
            date = self._status_time.strftime('%Y-%m-%dT%H:%M:%SZ')
            heartbeat_date = self._heartbeat_date.strftime('%Y-%m-%dT%H:%M:%SZ')
            closed = self._east_shutter == DomeShutterStatus.Closed and \
                self._west_shutter == DomeShutterStatus.Closed
            return {
                'date': date,
                'east_shutter': self._east_shutter,
                'west_shutter': self._west_shutter,
                'closed': closed,
                'heartbeat_date': heartbeat_date,
                'heartbeat_status': self._heartbeat_status,
                'heartbeat_remaining': self._heartbeat_time_remaining
            }

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Dome daemon')
    parser.add_argument('dome', choices=DOME_CONFIG.keys(), help='Telescope')
    args = parser.parse_args()
    config = DOME_CONFIG[args.dome]
    config.daemon.launch(DomeDaemon(config))
